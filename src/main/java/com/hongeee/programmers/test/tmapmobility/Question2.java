package com.hongeee.programmers.test.tmapmobility;

/**
 * 모든 섬과 섬 사이에 이동이 가능하도록 다리를 건설하려고 합니다.
 * 두 섬 간에 다리가 직접 연결되어 있지 않아도, 다른 섬들을 경유하여 이동할 수 있습니다.
 * 다리를 건설하면서, 다음과 같은 두 가지 목표를 달성하고자 합니다.
 *
 * 1. 모든 섬들은 다리로 직접 연결이 되거나, 다른 섬들을 경유하여 갈 수 있어야 합니다.
 * 2. 건설된 다리들 중, 가장 긴 다리의 길이를 가능한 짧게 해야 합니다.
 *
 * 각 섬의 좌표가 담겨있는 배열 x와 y가 매개변수로 주어집니다.
 * 위의 두 가지 목표를 달성하도록 다리를 건설했을 때, 가장 긴 다리의 길이를 return 하도록 solution 함수를 완성해주세요.
 *
 * 제한사항
 * - return 하는 값은 정수여야 합니다. 가장 긴 다리의 길이보다 같거나 큰 정수 중, 가장 작은 정수를 return 합니다.
 *
 * 각 섬의 좌표가 담겨있는 배열 x와 y가 매개변수로 주어집니다.
 * 위의 두 가지 목표를 달성하도록 다리를 건설했을 때, 가장 긴 다리의 길이를 return 하도록 solution 함수를 완성해주세요.
 *
 * 제한사항
 * - return 하는 값은 정수여야 합니다. 가장 긴 다리의 길이보다 같거나 큰 정수 중, 가장 작은 정수를 return 합니다.
 * - 예를 들어, 가장 긴 다리의 길이가 5.0이면 5를 return 하고, 5.1이면 6을 return 합니다.
 * - x, y는 정수 배열로, 섬들의 좌표를 담고 있습니다.
 * - 배열 x, y의 길이(=섬들의 개수)는 2 이상 100 이하이며 서로 같습니다.
 * - x[i], y[i]는 i번 섬의 x축, y축 좌표입니다. 즉, 섬의 개수가 N개라면, 섬의 번호는 0번부터 N-1번까지 부여됩니다.
 * - 섬의 면적은 0으로 간주합니다.
 * - 배열 x, y의 원소는 0 이상, 1,000 이하인 정수입니다.
 * - 2개 이상의 섬이 동일한 좌표 상에 위치하는 경우는 입력으로 주어지지 않습니다.
 * - 두 섬 간에 건설된 다리의 길이는 두 섬의 좌표 간 유클리드 거리입니다.
 *
 * 입출력 예
 * x  y return
 * [1,2,6,8]  [1,2,5,7] 5
 * [1,2,4,2]  [1,1,4,2] 3
 *
 * 입출력 예 설명
 * 입출력 예 #1
 * 위 그림과 같이 0번과 1번, 1번과 2번, 2번과 3번 섬을 연결하면 모든 섬이 연결됩니다.
 * 이 중 가장 긴 다리는 1번과 2번 섬을 연결하는 다리입니다.
 * 1번의 좌표가 (2, 2)이고 2번의 좌표가 (6, 5)이기 때문에, 두 섬간의 거리는 5입니다.
 * 길이가 5보다 작은 다리들만 건설하여 모든 섬을 연결하는 방법이 없기 때문에 5를 return 합니다.
 *
 * 입출력 예 #2
 * 위 그림과 같이 0번과 1번, 1번과 3번, 2번과 3번 섬을 연결하면 모든 섬이 연결됩니다.
 * 이 중 가장 긴 다리는 2번과 3번 섬을 연결하는 다리이며, 그 길이는 2 x sqrt(2)인데, 이보다 같거나 큰 정수 중에서, 가장 작은 정수는 3입니다.
 * 따라서 3을 return 합니다.
 *
 * 두 점 사이의 거리를 계산할 때, 두 점을 좌표로 표현하고 각각 대응하는 성분의 차의 제곱을 하여 더한 후 제곱근을 구한 값.
 */
public class Question2 {
  public int solution(int[] x, int[] y) {
    double longestDist = 0;

    // 섬들 끼리 연결 관계가 없으므로 모든 섬들 사이의 거리를 계산
    for (int i = 0; i < x.length - 1; i++) {
      double minDist = 0;

      // 각 섬은 최소 하나 이상의 섬과 다리로 연결되어야 하므로 가장 가까운 섬까지의 길이를 구함
      for (int j = i + 1; j < x.length; j++) {
        double dist = Math.sqrt(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2));
        minDist = minDist == 0 ? dist : Math.min(minDist, dist);
      }

      // 각 섬에서 가장 가까운 섬까지의 길이들 중 가장 긴 길이를 구함
      longestDist = longestDist == 0 ? minDist : Math.max(longestDist, minDist);
    }

    return (int) Math.ceil(longestDist);
  }
}
