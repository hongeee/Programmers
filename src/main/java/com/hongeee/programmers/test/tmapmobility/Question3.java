package com.hongeee.programmers.test.tmapmobility;

/**
 * 문제 설명
 * N x N 크기의 정사각형 격자로 이루어진 도시가 있습니다.
 * 도시에는 서로 다른 격자 칸에 버스 정류장이 있습니다.
 * 이때, 도시의 모든 격자 칸에 대해 가장 가까운 정류장과의 거리를 계산하려 합니다.
 * 각 칸에서는 상, 하, 좌, 우로만 움직일 수 있으며, 한 칸 이동하는데 거리 1로 계산합니다.
 *
 * 다음은 N = 3이고, 1행 2열에 정류장 한 개가 있는 예시입니다.
 *
 * 이때, 다음과 같이 이동하면 각 위치에서 정류장까지 가장 짧은 거리로 이동할 수 있습니다.
 *
 * 위와 같이 움직였을 때, 각 위치에서 가장 가까운 정류장까지 거리는 다음과 같습니다.
 *
 * (정류장이 있는 위치에서는 정류장과의 거리가 0입니다)
 *
 * 도시의 크기 N, 정류장의 위치 정보 bus_stop이 매개변수로 주어질 때, 도시 내 모든 위치에서 대해 가장 가까운 정류장과의 거리를 구해 N x N 크기의 2차원 배열에 담아 return 하도록 solution 함수를 완성해주세요.
 *
 * 제한사항
 * - N은 1 이상 600 이하의 정수입니다.
 * - bus_stop은 2차원 배열로, 행 길이는 1 이상 pow(N, 2) 이하이며 열의 길이는 항상 2 입니다.
 * - bus_stop의 각 행은 버스 정류장의 위치가 [행 번호, 열 번호] 순으로 들어있습니다.
 * - 동일한 버스 정류장 위치가 중복해 주어지지 않습니다.
 * - 버스 정류장의 행 번호, 열 번호는 1 이상 N 이하의 자연수로만 이루어져 있습니다.
 *
 * 입출력 예
 * N  bus_stop  result
 * 3  [[1,2,]]        [[1,0,1],[2,1,2],[3,2,3]]
 * 3  [[1,2,],[3,3]]  [[1,0,1],[2,1,1,],[2,1,0]]
 *
 * 입출력 예 설명
 * 입출력 예 #1
 * 문제 설명에서의 예시와 같습니다.
 *
 * 입출력 예 #2
 * 위와 같이 이동하면서 각 칸에서 정류장까지 최단거리로 이동할 수 있으며, 그때 각 칸에서 가장 가까운 정류장까지의 거리는 다음과 같습니다.
 */
public class Question3 {

  public int[][] solution(int N, int[][] bus_stop) {
    int[][] answer = new int[N][N];

    // bfs를 사용하려 했으나, 모든 칸에 대해 bfs를 수행하는 것보다 각 버스 정류장과의 거리를 비교하는 것이 나아 보임
    for (int x = 0; x < N; x++) {
      for (int y = 0; y < N; y++) {
        int minDist = 0;

        // 각 칸에서 각 버스 정류장까지의 거리를 구함
        for (int i = 0; i < bus_stop.length; i++) {
          int dist = Math.abs(x - (bus_stop[i][0] - 1)) + Math.abs(y - (bus_stop[i][1] - 1));

          if (dist == 0) {
            // 버스 정류장이 있는 칸
            minDist = 0;
            break;
          }

          // 각 칸에서 각 버스 정류장까지의 길이들 중 가장 짧은 길이를 구함
          minDist = minDist == 0 ? dist : Math.min(minDist, dist);
        }

        answer[x][y] = minDist;
      }
    }

    return answer;
  }
}
